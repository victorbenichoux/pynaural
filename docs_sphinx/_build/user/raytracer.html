<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Raytracer &mdash; Pynaural 0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Pynaural 0.1 documentation" href="../index.html" />
    <link rel="up" title="User Guide" href="index.html" />
    <link rel="next" title="Signal processing" href="signal.html" />
    <link rel="prev" title="User Guide" href="index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">Pynaural 0.1 documentation</a></div>
        <div class="rel">
          <a href="index.html" title="User Guide"
             accesskey="P">previous</a> |
          <a href="signal.html" title="Signal processing"
             accesskey="N">next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="raytracer">
<h1>Raytracer<a class="headerlink" href="#raytracer" title="Permalink to this headline">¶</a></h1>
<p>This documentation deals with the basic raytracing functions.</p>
<span class="target" id="module-pynaural.raytracer.scenes"></span><dl class="class">
<dt id="pynaural.raytracer.scenes.GeometricScene">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.scenes.</tt><tt class="descname">GeometricScene</tt><big>(</big><em>objects</em>, <em>stopcondition=30</em>, <em>nrays=1000000.0</em>, <em>precision=1e-05</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that encapsulates all the geometric data of a scene, and
takes care of the raytracing itself.</p>
<p>GeometricScenes may contain any number of Surface and Source
objects. Those are used for raytracing a Beam through the
<tt class="docutils literal"><span class="pre">render</span></tt> method.</p>
<p>The raytracing algorithm can be controlled in one of two ways: by
changing the stop condition, or by changing the precision
attribute.</p>
<p>** Initialization **</p>
<p><tt class="docutils literal"><span class="pre">stopcondition</span> <span class="pre">=</span> <span class="pre">30</span></tt> defines the stopcondition of the raytracing algorithm.</p>
<p><tt class="docutils literal"><span class="pre">precision</span> <span class="pre">=</span> <span class="pre">1e5</span></tt> defines the threshold of precision for
avoiding autointersection during raytracing. Due to numerical
(in)accuracy issues, sometimes a ray that just reflected on a
surface will come from the back of said surface and reintersect
it. That&#8217;s why we use this threshold that prevents this by
forbidding any intersection with a surface closer than <tt class="docutils literal"><span class="pre">precision</span></tt></p>
<p>`` nrays`` Defines the default number of rays to be generated in
that scene (see get_beam)</p>
<p>** Object Management **</p>
<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.add">
<tt class="descname">add</tt><big>(</big><em>*obj</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the given object, or list of objects to the
GeometricScene. Objects may be either Sources or Surfaces.</p>
</dd></dl>

<p>** Raytracing **</p>
<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.render">
<tt class="descname">render</tt><big>(</big><em>obj</em>, <em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.render"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Raytracing algorithm.</p>
<p><tt class="docutils literal"><span class="pre">obj</span></tt> Defines on which object to do the rendering. 
For Receiver inputs, the Scene decides
which Beam to generate, generates one beam for all source objects
and renders it.
If <tt class="docutils literal"><span class="pre">obj</span></tt> is a beam, then the beam is rendered in the scene and
returned.</p>
<p>Keyword Arguments:</p>
<p><tt class="docutils literal"><span class="pre">cpu</span> <span class="pre">=</span> <span class="pre">1</span></tt> If set to more than 1 the algorithm will be
distributed across CPUs using playdoh. (experimental)</p>
<p><tt class="docutils literal"><span class="pre">debug</span> <span class="pre">=</span> <span class="pre">False</span></tt> If set to True, will be <em>very</em> verbose.</p>
<p><tt class="docutils literal"><span class="pre">nrays</span> <span class="pre">=</span> <span class="pre">None</span></tt> passed to get_beam.</p>
</dd></dl>

<dl class="attribute">
<dt id="pynaural.raytracer.scenes.GeometricScene.stopcondition">
<tt class="descname">stopcondition</tt><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.stopcondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.stopcondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of the stop condition.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.set_stopcondition">
<tt class="descname">set_stopcondition</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.set_stopcondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.set_stopcondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the stop condition of the raytracing algorithm to the
value given as an argument. If the value is an integer, then
the stop condition will be the maximum number of reflections
computed. Otherwise, it is the longest time-of-flight of the rays.</p>
</dd></dl>

<p>** Beam handling **</p>
<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.get_beam">
<tt class="descname">get_beam</tt><big>(</big><em>position</em>, <em>nrays=1000000.0</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.get_beam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.get_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Beam object originating at a given 3D position and all the
sources in the GeometricScene.</p>
<p><tt class="docutils literal"><span class="pre">nrays</span> <span class="pre">=</span> <span class="pre">1e5</span></tt> Defines the number of rays to be generated per
couple (receiver, source). Note: This is ignored when the rays
are known exactly (see SquareRoomScene for example).</p>
</dd></dl>

<p>** Geometry **</p>
<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.volume">
<tt class="descname">volume</tt><big>(</big><em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the volume of the enclosed space in the
GeometricScene around the ref_point using a monte carlo method.</p>
<p>More precisely, draws Npoints random points within the slab
centered on ref_point, with coordinates within abs_max of this
points. Then evaluates the volume by testing whether or not
each point is in the closed space around the reference point.</p>
<p>Keyword arguments:</p>
<p><tt class="docutils literal"><span class="pre">abs_max</span> <span class="pre">=</span> <span class="pre">10</span></tt> Can be a (3x2) ndarray with min/max values
along each dimension, or just a single value that defines the
maximum absolute value of the generate coordinates</p>
<p><tt class="docutils literal"><span class="pre">Npoints</span> <span class="pre">=</span> <span class="pre">1e7</span></tt> Defines the number of points to generate, a
higher value may lead to more precise estimation, but too high
values raise a MemoryError.</p>
<p><tt class="docutils literal"><span class="pre">Niter</span> <span class="pre">=</span> <span class="pre">1</span></tt> If set to more than one then the volume
computations is run Niter times and averaged.</p>
<p><tt class="docutils literal"><span class="pre">ref_point</span> <span class="pre">=</span> <span class="pre">ORIGIN</span></tt> Volume will be measured around the
point ref_point.</p>
</dd></dl>

<p>** Misc. **
.. automethod :: plotsources</p>
<p>** Acoustical measures **</p>
<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.modedensity">
<tt class="descname">modedensity</tt><big>(</big><em>freq</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.modedensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.modedensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mode density ratio, ie deltaN/deltaf, the number
of modes per bandwidth of the room (intr.acous. p 111) at a
given frequency.</p>
<p>NB: 
- approx, works for high freqs with regards to f0
- homogene a un temps</p>
<p>For a sound that lasts t0, with fundamental at f0, one must
find about 10 modes in the frequency band centered around f0
of width 2*pi/t0.
That is the number of modes for a signal defined as up, in a
band of width deltaf is:
room.modedensity(f)*deltaf
for the sound to be intelligible, one must have</p>
<p>Notes:
- wtf?</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.eyring">
<tt class="descname">eyring</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.eyring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.eyring" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates Eyring&#8217;s formula (RT60) for the current scene.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.sabine">
<tt class="descname">sabine</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.sabine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.sabine" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates Sabine&#8217;s formula (RT60) for the current scene.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.reflectionnumber">
<tt class="descname">reflectionnumber</tt><big>(</big><em>t</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.reflectionnumber"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.reflectionnumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of reflections expected in a rectangular
hall before time t.
Follows the formula 2pi(ct)**3/(3V) (Dalenback 96, ref12)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">add</tt><big>(</big><em>*obj</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.add"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Adds the given object, or list of objects to the
GeometricScene. Objects may be either Sources or Surfaces.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.area">
<tt class="descname">area</tt><big>(</big><em>i</em>, <em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the surface of the i&#8217;th Surface object in the
scene. It is computed alongside the volume using a Monte Carlo method.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.compute_volume_areas_once">
<tt class="descname">compute_volume_areas_once</tt><big>(</big><em>ref_point=Point (0</em>, <em>0</em>, <em>0)</em>, <em>abs_max=10.0</em>, <em>Npoints=10000000.0</em>, <em>debug=False</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.compute_volume_areas_once"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.compute_volume_areas_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo method for estimation of the volumes and surface areas of an enclosed GeometricScene.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">eyring</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.eyring"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Evaluates Eyring&#8217;s formula (RT60) for the current scene.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">get_beam</tt><big>(</big><em>position</em>, <em>nrays=1000000.0</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.get_beam"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns a Beam object originating at a given 3D position and all the
sources in the GeometricScene.</p>
<p><tt class="docutils literal"><span class="pre">nrays</span> <span class="pre">=</span> <span class="pre">1e5</span></tt> Defines the number of rays to be generated per
couple (receiver, source). Note: This is ignored when the rays
are known exactly (see SquareRoomScene for example).</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.is_inside">
<tt class="descname">is_inside</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.is_inside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.is_inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to tell whether an object is inside a convex scene or
not. It may not work for non-convex geometries.</p>
<p>`` obj`` may be any object with a <tt class="docutils literal"><span class="pre">position</span></tt> attribute, or a
(3xn) ndarray, or a Vector/Point.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">modedensity</tt><big>(</big><em>freq</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.modedensity"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Computes the mode density ratio, ie deltaN/deltaf, the number
of modes per bandwidth of the room (intr.acous. p 111) at a
given frequency.</p>
<p>NB: 
- approx, works for high freqs with regards to f0
- homogene a un temps</p>
<p>For a sound that lasts t0, with fundamental at f0, one must
find about 10 modes in the frequency band centered around f0
of width 2*pi/t0.
That is the number of modes for a signal defined as up, in a
band of width deltaf is:
room.modedensity(f)*deltaf
for the sound to be intelligible, one must have</p>
<p>Notes:
- wtf?</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.modes">
<tt class="descname">modes</tt><big>(</big><em>bound=1000.0</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.modes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the possible room mode frequencies up to a certain
<tt class="docutils literal"><span class="pre">bound</span></tt> (in Hz) given as an argument.</p>
<p>Note that since there are a huge number of room modes in high
frequencies, imposing a high bound (more than a few kHz) will
most likely raise a MemoryError.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.GeometricScene.plotsources">
<tt class="descname">plotsources</tt><big>(</big><em>display=False</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.plotsources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GeometricScene.plotsources" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the sources in a 3D axes object.</p>
<p><tt class="docutils literal"><span class="pre">display</span> <span class="pre">=</span> <span class="pre">False</span></tt> If set to True, then show() is called.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reflectionnumber</tt><big>(</big><em>t</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.reflectionnumber"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns the number of reflections expected in a rectangular
hall before time t.
Follows the formula 2pi(ct)**3/(3V) (Dalenback 96, ref12)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">render</tt><big>(</big><em>obj</em>, <em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.render"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Raytracing algorithm.</p>
<p><tt class="docutils literal"><span class="pre">obj</span></tt> Defines on which object to do the rendering. 
For Receiver inputs, the Scene decides
which Beam to generate, generates one beam for all source objects
and renders it.
If <tt class="docutils literal"><span class="pre">obj</span></tt> is a beam, then the beam is rendered in the scene and
returned.</p>
<p>Keyword Arguments:</p>
<p><tt class="docutils literal"><span class="pre">cpu</span> <span class="pre">=</span> <span class="pre">1</span></tt> If set to more than 1 the algorithm will be
distributed across CPUs using playdoh. (experimental)</p>
<p><tt class="docutils literal"><span class="pre">debug</span> <span class="pre">=</span> <span class="pre">False</span></tt> If set to True, will be <em>very</em> verbose.</p>
<p><tt class="docutils literal"><span class="pre">nrays</span> <span class="pre">=</span> <span class="pre">None</span></tt> passed to get_beam.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sabine</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.sabine"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Evaluates Sabine&#8217;s formula (RT60) for the current scene.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">set_stopcondition</tt><big>(</big><em>val</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.set_stopcondition"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Sets the stop condition of the raytracing algorithm to the
value given as an argument. If the value is an integer, then
the stop condition will be the maximum number of reflections
computed. Otherwise, it is the longest time-of-flight of the rays.</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">stopcondition</tt><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.stopcondition"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns the current value of the stop condition.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">volume</tt><big>(</big><em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GeometricScene.volume"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Estimates the volume of the enclosed space in the
GeometricScene around the ref_point using a monte carlo method.</p>
<p>More precisely, draws Npoints random points within the slab
centered on ref_point, with coordinates within abs_max of this
points. Then evaluates the volume by testing whether or not
each point is in the closed space around the reference point.</p>
<p>Keyword arguments:</p>
<p><tt class="docutils literal"><span class="pre">abs_max</span> <span class="pre">=</span> <span class="pre">10</span></tt> Can be a (3x2) ndarray with min/max values
along each dimension, or just a single value that defines the
maximum absolute value of the generate coordinates</p>
<p><tt class="docutils literal"><span class="pre">Npoints</span> <span class="pre">=</span> <span class="pre">1e7</span></tt> Defines the number of points to generate, a
higher value may lead to more precise estimation, but too high
values raise a MemoryError.</p>
<p><tt class="docutils literal"><span class="pre">Niter</span> <span class="pre">=</span> <span class="pre">1</span></tt> If set to more than one then the volume
computations is run Niter times and averaged.</p>
<p><tt class="docutils literal"><span class="pre">ref_point</span> <span class="pre">=</span> <span class="pre">ORIGIN</span></tt> Volume will be measured around the
point ref_point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.scenes.VoidScene">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.scenes.</tt><tt class="descname">VoidScene</tt><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#VoidScene"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.VoidScene" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to work in anechoic environments.</p>
<p>In this setting the environment impulse response will aways be dirac-like.</p>
</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.scenes.RoomScene">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.scenes.</tt><tt class="descname">RoomScene</tt><big>(</big><em>l</em>, <em>L</em>, <em>h</em>, <em>nreflections=5</em>, <em>model={'alpha': 0.01}</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#RoomScene"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.RoomScene" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for working with rectangular room shapes.</p>
<p>It creates a cuboid-shaped acoustic scene, the ground being the z = 0 plane, with the origin in the middle of the ground. The computations are much faster here since they are base on the image method described in the 1979 Allen and Berkley paper (&#8220;Image Method for Efficiently Simulating Small-room Acoustics&#8221;).</p>
<p>** Sample usage **</p>
<p>room = RoomScene(3*m, 4*m, 2.5*m)</p>
<dl class="method">
<dt id="pynaural.raytracer.scenes.RoomScene.area">
<tt class="descname">area</tt><big>(</big><em>i</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#RoomScene.area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.RoomScene.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Here it is computed exactly.</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.scenes.RoomScene.volume">
<tt class="descname">volume</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#RoomScene.volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.RoomScene.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Here it is computed exactly.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.scenes.GroundScene">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.scenes.</tt><tt class="descname">GroundScene</tt><big>(</big><em>mode='ground'</em>, <em>stopcondition=None</em>, <em>model={'alpha': 1.0}</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/scenes.html#GroundScene"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.scenes.GroundScene" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to work with simple settings in which only a ground/wall is present.</p>
<p>The environment is modeled using a single plane, with arbitrary
model.</p>
<p>** Initialization **</p>
<p><tt class="docutils literal"><span class="pre">mode</span> <span class="pre">=</span> <span class="pre">'ground'</span></tt> By default the Plane object added to the Scene
is GROUND, that is the plane at z = 0, one can set this mode to
WALL in which case the wall is placed at x = 0, facing right.</p>
<p>** Sample usage **</p>
<p>To model a simple situation where the ground absorbs 3dB of
signal, one can do:</p>
<p>outdoor = GroundScene(model = RigidReflectionModel(3*dB))</p>
</dd></dl>

<span class="target" id="module-pynaural.raytracer.receivers"></span><dl class="class">
<dt id="pynaural.raytracer.receivers.Receiver">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.receivers.</tt><tt class="descname">Receiver</tt><big>(</big><em>loc</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#Receiver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.Receiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent class for receiver objects. Unless subclassed, it only requires a position attribute.</p>
</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.receivers.OrientedReceiver">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.receivers.</tt><tt class="descname">OrientedReceiver</tt><big>(</big><em>position</em>, <em>orientation</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#OrientedReceiver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.OrientedReceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>OrientedReceiver is just a regular receiver but oriented. This provides the reference for the azimuth and elevation in the HRTF computations</p>
</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.receivers.HRTFReceiver">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.receivers.</tt><tt class="descname">HRTFReceiver</tt><big>(</big><em>position</em>, <em>hrtfset</em>, <em>orientation=Vector (0</em>, <em>1</em>, <em>0)</em>, <em>is_distancedependent=False</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#HRTFReceiver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.HRTFReceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>A single-point receiver that uses HRTF to finally filter IRs. The
position is the head center.</p>
<p>** Initialization **</p>
<p><tt class="docutils literal"><span class="pre">position</span></tt> can be a Quantity or numeric object. If so the
Receiver is positioned at position*UP. Alternatively it can be
just a Vector or Point giving the real position.</p>
<p>`` hrtfset `` An ImpulseResponse object containing the HRIR data</p>
<p>`` orientation = FRONT `` Orientation of the Receiver object.</p>
<p>** Methods **</p>
<p>** Advanced **</p>
<p>An HRTFReceiver has to implement the <a href="#id1"><span class="problematic" id="id2">``</span></a>get_hrir&#8217;&#8217; method.
<a href="#id3"><span class="problematic" id="id4">``</span></a>get_hrir(az, el [,distance])&#8217;&#8217; returns the hrir pair for the given direction.</p>
<p>Note that if the <a href="#id5"><span class="problematic" id="id6">``</span></a>distance&#8217;&#8217; argument is supported by <a href="#id7"><span class="problematic" id="id8">``</span></a>get_hrir&#8217;&#8217; then the <a href="#id9"><span class="problematic" id="id10">``</span></a>is_distancedependent&#8217;&#8217; property must be set to True.</p>
<dl class="method">
<dt id="pynaural.raytracer.receivers.HRTFReceiver.collapse">
<tt class="descname">collapse</tt><big>(</big><em>irs</em>, <em>monaural=None</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#HRTFReceiver.collapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.HRTFReceiver.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the HRTF to irs resulting from applying a model to the paths rendered by a scene
By default applies left and right HRTF to all the rays. In the case where rays represent the path to one ear only, use monaural = &#8216;left&#8217; or &#8216;right&#8217; to apply the respective HRTFs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>irs</strong> &#8211; </li>
<li><strong>monaural</strong> &#8211; either None, &#8216;left&#8217; or &#8216;right&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Binaural Impulse Response for the scene</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.receivers.HRTFReceiver.computeHRIRs">
<tt class="descname">computeHRIRs</tt><big>(</big><em>*args</em>, <em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#HRTFReceiver.computeHRIRs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.HRTFReceiver.computeHRIRs" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to fetch HRIRs relative to a result from an AcousticScene,</p>
<p>can be used either with a scene + beam (result of rendering)
or simply with a list of coordinates of the form (az,el) where
az and el are in my convention, but for that rather use get_hrir</p>
<p>also the method kwargs can switch between interpolation
(bilinear) or closest behavior,</p>
</dd></dl>

<dl class="method">
<dt id="pynaural.raytracer.receivers.HRTFReceiver.computeIRs">
<tt class="descname">computeIRs</tt><big>(</big><em>*args</em>, <em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#HRTFReceiver.computeIRs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.HRTFReceiver.computeIRs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scene response convolved by the hrtfs.
depends on the form of the HRTFs.</p>
<p>Computes the IRs from the scene given as a first argument, and convolves it correctly with the Receiver.</p>
<p>Sample usage:
receiver.computeIRs(scene,</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.receivers.IRCAMSubjectReceiver">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.receivers.</tt><tt class="descname">IRCAMSubjectReceiver</tt><big>(</big><em>position</em>, <em>orientation=Vector (0</em>, <em>1</em>, <em>0)</em>, <em>path=None</em>, <em>subject=3017</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/receivers.html#IRCAMSubjectReceiver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.receivers.IRCAMSubjectReceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>A receiver based on a IRCAM HRIR set</p>
</dd></dl>

<span class="target" id="module-pynaural.raytracer.sources"></span><dl class="class">
<dt id="pynaural.raytracer.sources.BaseSource">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.sources.</tt><tt class="descname">BaseSource</tt><big>(</big><em>loc</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#BaseSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.BaseSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to work with acoustic sources, practically one never quite
uses BaseSource, but Source instead.</p>
<p>** Identification **</p>
<p>When added to a scene, any Source object is given an id that
corresponds to its position in the <tt class="docutils literal"><span class="pre">surfaces</span></tt> attribute of the
GeometricScene.</p>
<dl class="method">
<dt id="pynaural.raytracer.sources.BaseSource.set_id">
<tt class="descname">set_id</tt><big>(</big><em>id</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#BaseSource.set_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.BaseSource.set_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an Id relative to a surface for simple use of targetted beams</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.sources.Source">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.sources.</tt><tt class="descname">Source</tt><big>(</big><em>loc</em>, <em>ref=0.01</em>, <em>model=None</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#Source"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.Source" title="Permalink to this definition">¶</a></dt>
<dd><p>Spherical Source, should be used instead of Source because
otherwise numerical problems in raytracing arise.
reference distance is of 1cm.
Initialized with a location.</p>
<dl class="staticmethod">
<dt id="pynaural.raytracer.sources.Source.pair_sources">
<em class="property">static </em><tt class="descname">pair_sources</tt><big>(</big><em>position</em>, <em>isd</em>, <em>orientation=Vector (0</em>, <em>1</em>, <em>0)</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#Source.pair_sources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.Source.pair_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Places two sources separated by a certain distance, with a certain orientation... Both in the same plane</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pynaural.raytracer.sources.Source.relative_sources">
<em class="property">static </em><tt class="descname">relative_sources</tt><big>(</big><em>*args</em>, <em>**kwdargs</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#Source.relative_sources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.Source.relative_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to place sources positioned relatively to any
object with a position attribute.</p>
<p>Sample usage, with a function as a filter, relatively to a
receiver</p>
<p>relative_sources(receiver, 1*meter, lambda azim,elev: azim ==0)</p>
<p>This will place Sources where the receiver has HRTFs (no interpolation)</p>
<p>Sample usage, with lists of coordinates:
relative_sources(receiver, [1*meter 2*meter], [90 180], 15)</p>
<p>This places 4 sources at 1 meter, 90 Az, 15 El, etc...</p>
<p>Additionally, one can pass a list of [(d, az, el), ...] which will place only one source for each d, az, el triplet.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynaural.raytracer.sources.EqualizedSource">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.sources.</tt><tt class="descname">EqualizedSource</tt><big>(</big><em>loc</em>, <em>ref=0.01</em>, <em>model=None</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#EqualizedSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.EqualizedSource" title="Permalink to this definition">¶</a></dt>
<dd><p>** Source equalization **</p>
<p>When rays reach the source, they can be equalized according to a
scheme defined in model (not yet implemented). Until this feature
appears, the only equalization done is uniform. To do so, one can
compute a voronoi partition of the rays arriving on the sphere.</p>
<dl class="method">
<dt id="pynaural.raytracer.sources.EqualizedSource.voronoi_partition">
<tt class="descname">voronoi_partition</tt><big>(</big><em>beam</em>, <em>method='directions'</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#EqualizedSource.voronoi_partition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.EqualizedSource.voronoi_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of weights (0&lt;weight&lt;1) that correspond to
the surface area covered by the voronoi partition of the
sphere around the source given by the rays&#8217; arrival
directions.
This is further used as a cue of the amount of acoustic power
this ray is carrying.</p>
<p><em>advanced</em>
<tt class="docutils literal"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'direction'</span></tt> which data to use to construct the
voronoi partition. If it is &#8216;directions&#8217; then the directions
of the incoming rays is used (actually -directions). If it is
&#8216;origins&#8217;, then the vectors used are vectors from center of
the source to the origins of the rays (that lay on the surface
of the source).</p>
</dd></dl>

<p>By default an EqualizedSource is omnidirectional, so
get_equalization yields directly the result of voronoi_partition.</p>
<dl class="method">
<dt id="pynaural.raytracer.sources.EqualizedSource.get_equalization">
<tt class="descname">get_equalization</tt><big>(</big><em>beam</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#EqualizedSource.get_equalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.sources.EqualizedSource.get_equalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the equalization weights from the beam, representing
rays arriving to the source. Since the source is
omnidirectional, the arriving rays are weigh according to the
surface of the sphere they account for, so it is the result of
voronoi_parittion.</p>
</dd></dl>

<p>Other types may come in the future.</p>
<dl class="method">
<dt>
<tt class="descname">get_equalization</tt><big>(</big><em>beam</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#EqualizedSource.get_equalization"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns the equalization weights from the beam, representing
rays arriving to the source. Since the source is
omnidirectional, the arriving rays are weigh according to the
surface of the sphere they account for, so it is the result of
voronoi_parittion.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">voronoi_partition</tt><big>(</big><em>beam</em>, <em>method='directions'</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/sources.html#EqualizedSource.voronoi_partition"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns an array of weights (0&lt;weight&lt;1) that correspond to
the surface area covered by the voronoi partition of the
sphere around the source given by the rays&#8217; arrival
directions.
This is further used as a cue of the amount of acoustic power
this ray is carrying.</p>
<p><em>advanced</em>
<tt class="docutils literal"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'direction'</span></tt> which data to use to construct the
voronoi partition. If it is &#8216;directions&#8217; then the directions
of the incoming rays is used (actually -directions). If it is
&#8216;origins&#8217;, then the vectors used are vectors from center of
the source to the origins of the rays (that lay on the surface
of the source).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pynaural.raytracer.sources.pair_sources">
<tt class="descclassname">pynaural.raytracer.sources.</tt><tt class="descname">pair_sources</tt><big>(</big><em>position</em>, <em>isd</em>, <em>orientation=Vector (0</em>, <em>1</em>, <em>0)</em><big>)</big><a class="headerlink" href="#pynaural.raytracer.sources.pair_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Places two sources separated by a certain distance, with a certain orientation... Both in the same plane</p>
</dd></dl>

<dl class="function">
<dt id="pynaural.raytracer.sources.relative_sources">
<tt class="descclassname">pynaural.raytracer.sources.</tt><tt class="descname">relative_sources</tt><big>(</big><em>*args</em>, <em>**kwdargs</em><big>)</big><a class="headerlink" href="#pynaural.raytracer.sources.relative_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to place sources positioned relatively to any
object with a position attribute.</p>
<p>Sample usage, with a function as a filter, relatively to a
receiver</p>
<p>relative_sources(receiver, 1*meter, lambda azim,elev: azim ==0)</p>
<p>This will place Sources where the receiver has HRTFs (no interpolation)</p>
<p>Sample usage, with lists of coordinates:
relative_sources(receiver, [1*meter 2*meter], [90 180], 15)</p>
<p>This places 4 sources at 1 meter, 90 Az, 15 El, etc...</p>
<p>Additionally, one can pass a list of [(d, az, el), ...] which will place only one source for each d, az, el triplet.</p>
</dd></dl>

<span class="target" id="module-pynaural.raytracer.models"></span><p>This is a new class designed to replace the old Model paradigm that is getting messy and outdated</p>
<dl class="class">
<dt id="pynaural.raytracer.models.DelayAttenuationModel">
<em class="property">class </em><tt class="descclassname">pynaural.raytracer.models.</tt><tt class="descname">DelayAttenuationModel</tt><big>(</big><em>samplerate=44100.0</em>, <em>nfft=1024</em>, <em>scene=None</em><big>)</big><a class="reference internal" href="../_modules/pynaural/raytracer/models.html#DelayAttenuationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynaural.raytracer.models.DelayAttenuationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Accumulates delays and attenuations for each rays, then if relevant also uses HRTFs</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">Raytracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal.html">Signal processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="binaural.html">Binaural</a></li>
<li class="toctree-l2"><a class="reference internal" href="geometry.html">Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="receivers.html">Receivers</a></li>
</ul>
</li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="index.html" title="User Guide"
             >previous</a> |
          <a href="signal.html" title="Signal processing"
             >next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="../_sources/user/raytracer.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2013, Victor Benichoux.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>